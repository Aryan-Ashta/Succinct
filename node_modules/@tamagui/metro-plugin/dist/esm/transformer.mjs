import { outputFile, pathExists } from "fs-extra";
import worker from "metro-transform-worker";
import { join, posix, sep } from "node:path";
import { createExtractor, extractToClassNames } from "@tamagui/static";
const extractor = createExtractor();
async function transform(config, projectRoot, filename, data, options) {
  const ogPath = config.ogTransformPath || config.transformerPath,
    transformer = ogPath ? require(ogPath).transform : worker.transform;
  if (config.tamagui.disable || options.platform !== "web" || options.type === "asset" || filename.includes("node_modules")) return transformer(config, projectRoot, filename, data, options);
  if (
  // could by a styled() call:
  filename.endsWith(".ts") || filename.endsWith(".tsx") || filename.endsWith(".jsx")) {
    const sourcePath = toPosixPath(join(projectRoot, filename)),
      source = `${data}`,
      out = await extractToClassNames({
        extractor,
        options: {
          // @ts-ignore
          platform: "web",
          ...config.tamagui
        },
        shouldPrintDebug: source.startsWith("// debug-verbose") ? "verbose" : source.startsWith("// debug"),
        source,
        sourcePath
      });
    if (out?.styles) {
      const tmpDir = join(projectRoot, ".tamagui", "css"),
        outStylePath = toPosixPath(join(tmpDir, `${filename}`.replace(/[^a-zA-Z0-9]/gi, "") + ".css"));
      if (process.env.DEBUG?.includes("tamagui") && console.info(" Outputting CSS file:", outStylePath), process.env.TAMAGUI_METRO_INLINE_CSS !== "0") {
        const cssInjectionCode = `
          (function() {
            if (typeof document !== 'undefined') {
              var css = ${JSON.stringify(out.styles)};
              var style = document.createElement('style');
              style.type = 'text/css';
              style.appendChild(document.createTextNode(css));
              document.head.appendChild(style);
            }
          })();
          `;
        return transformer(config, projectRoot, filename, Buffer.from(`${out.js}
${cssInjectionCode}`, "utf-8"), options);
      }
      const existsAlready = await pathExists(outStylePath);
      return await outputFile(outStylePath, out.styles, "utf-8"), existsAlready || (await new Promise(res => setTimeout(res, process.env.TAMAGUI_METRO_CSS_EMIT_DELAY ? +process.env.TAMAGUI_METRO_CSS_EMIT_DELAY : 1e3))), transformer(config, projectRoot, filename, Buffer.from(`${out.js}
require("${outStylePath}")`, "utf-8"), options);
    }
  }
  return transformer(config, projectRoot, filename, data, options);
}
function toPosixPath(path) {
  return path.split(sep).join(posix.sep);
}
export { transform };
//# sourceMappingURL=transformer.mjs.map
